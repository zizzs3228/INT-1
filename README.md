## Чтобы успешно поднять демонстрационный стенд:
### 1
giot clone
```
git clone https://github.com/zizzs3228/INT-1.git
```
### 2
Поставить виртуальное окружения, *если необходиммо:*
```
python -m venv /path/to/venv
source /path/to/venv/activate
```
### 3
Поставить пакеты:
```
pip install -r requirements.txt
```
### 4
Поднять докер с заполненной бдшкой
```
docker compose up --build -d
```
### 5
Запустить pytest
```
pytest INT-1.py
```
![image](https://github.com/zizzs3228/INT-1/assets/73750173/718fd5f4-35cf-4df2-bae0-d1fcc08a5833)
Успешное выполнение тестов. 1 и 4 тест являются демонстрационными, основное задание - это 2 и 3


![image](https://github.com/zizzs3228/INT-1/assets/73750173/c536c6b8-9fde-437c-81b7-5ebbcb0f781d)
Интересные факты во время тестов: 
1. При поиске с индексом меняется порядок элементов в возвращаемом массиве через fetchall(), поэтому перед assertом "==" нужно сделать сортировку или сделать из массивов set.
2. На малых данных у меня иногда проскакивало, что без индекса быстрее, но, в основном, индекс, всё же, быстрее

![image](https://github.com/zizzs3228/INT-1/assets/73750173/f7ff73cd-918b-4b92-b155-40efb14bc29f)
Случай не срабатывания индекса. Опытным путём я нашёл неэффективную работу индекса на строках - можно видеть на тестах в первой таблице(в верхней части скриншота).
Соответственно, чем выше индекс, тем хуже эффективность индекса. Однако, на строках(VARCHAR) СУБД также выбирает индекс, который добавлен, а вот на тексте(нижняя часть скриншота) не срабатывает индекс вообще, везде в дополнительной информации стоит "Using Where", что значит, что индекс не используется.
